from abc import ABC, abstractmethod
from enum import Enum
import math
import numpy as np
import pandas as pd
import scipy.stats as ss


class PayoffType(str, Enum):
    Call = 'Call'
    Put = 'Put'

class Direction(str, Enum):
    Long = 'Long'
    Short = 'Short'


class EuropeanOption():
    def __init__(self, expiry, strike, payoffType):
        self.expiry = expiry
        self.strike = strike
        self.payoffType = payoffType
    def payoff(self, S):
        if self.payoffType == PayoffType.Call:
            return max(S - self.strike, 0)
        elif self.payoffType == PayoffType.Put:
            return max(self.strike - S, 0)
        else:
            raise Exception("payoffType not supported: ", self.payoffType)
    def valueAtNode(self, t, S, continuation):
        if continuation == None:
            return self.payoff(S)
        else:
            return continuation
        

# class Portfolio:
#     def __init__(self):
#         self.asset = []
#         self.account = {}

#     def addAsset(self, asset):
#         if asset not in self.account.values():
#             self.asset.append(asset)
#         else:
#             raise Exception(f"The asset {asset} is already in your account")
    
    
class PathsGeneration(ABC):
    def __init__(self, currentVal, currentTime, steps, expiry, interestRate):
        self.currentVal = currentVal
        self.currentTime = currentTime
        self.steps = steps
        self.expiry = expiry
        self.interestRate = interestRate
        self.stepSize = expiry/steps
        
    @abstractmethod
    def progress_to_t(self):
        pass


class HedgingStrategy(ABC):
    def __init__(self, direction, payoffType, spot, strike, expiry):
        self.spot = spot
        self.strike = strike
        self.expiry = expiry
        self.direction = direction
        self.payoffType = payoffType

    @abstractmethod
    def rebalance(self):
        pass
    

class TradingSimulator:
    def __init__(self, cash, PathsGeneration, HedgingStrategy):
        self.PnL = cash
        self.PathsGeneration = PathsGeneration
        self.HedgingStrategy = HedgingStrategy
        self.book = pd.DataFrame(columns=['Time', 'Price', 'Delta', 'Total Delta Position',
                                          'Adjustment Cashflow', 'Interest on Adjustments'])
        

    def trading(self):
        while self.PathsGeneration.currentTime < self.PathsGeneration.expiry:
            self.PathsGeneration.progress_to_t()
            row = [None for _ in range(6)]
            spot_price = self.PathsGeneration.currentVal
            stock_rebalance = self.HedgingStrategy.rebalance()
            self.HedgingStrategy.spot = spot_price
            self.HedgingStrategy.expiry = self.PathsGeneration.expiry - self.PathsGeneration.currentTime

            row[0] = self.PathsGeneration.currentTime
            row[1] = spot_price
            row[2] = stock_rebalance
            # row[3] = the change of delta
            row[4] = stock_rebalance * spot_price
            # row[5] = interest generated by 'Adjustment Cashflow'
            self.book.loc[len(self.book)] = row

        self.book['Total Delta Position'] = self.book['Delta'] - self.book['Delta'].shift(1)
        self.book['Interest on Adjustments'] = self.book.apply(lambda x: x['Adjustment Cashflow']*self.PathsGeneration.interestRate*x['Time'], 
                                                               axis=1)

    def ProfitAndLost(self):
        for position, price in self.book['stock']:
            self.PnL += position * price
        
        return self.PnL
            

class DeltaHedging(HedgingStrategy):
    def __init__(self, direction, payoffType, spot, strike, expiry, interest_rate, volatility):
        super().__init__(direction, payoffType, spot, strike, expiry)
        self.interest_rate = interest_rate
        self.volatility = volatility
        self.d_1 = ((math.log(self.spot / self.strike) + (self.interest_rate + self.volatility ** 2 / 2) * expiry) 
                    / (volatility * math.sqrt (expiry)))

    def rebalance(self):
        if self.payoffType == PayoffType.Call:
            if self.direction == 'Long':
                return ss.norm.cdf(self.d_1)
            elif self.direction == 'Short':
                return -ss.norm.cdf(self.d_1)
            else:
                raise Exception(f"Invalid direction: {self.direction}")
        
        if self.payoffType == PayoffType.Put:
                if self.direction == 'Long':
                    return ss.norm.cdf(self.d_1) - 1
                elif self.direction == 'Short':
                    return - (ss.norm.cdf(self.d_1) - 1)
                else:
                    raise Exception(f"Invalid direction: {self.direction}")
        else:
            raise Exception(f"The payoff type {self.payoffType} is not supported")

    

class GeometricBrownianMotion(PathsGeneration):
    def __init__(self, currentVal, currentTime, steps, expiry, interestRate, volatility):
        super().__init__(currentVal, currentTime, steps, expiry, interestRate)
        self.drift = interestRate
        self.volatility = volatility
    
    def progress_to_t(self):
        change = ((self.drift - 0.5 * self.volatility ** 2) * self.stepSize 
                + self.volatility * math.sqrt(self.stepSize) * np.random.normal(0, 1))
        self.currentVal = math.exp(math.log(self.currentVal) + change)
        self.currentTime += self.stepSize
        # print(f"Time is {self.currentTime}, value is {self.currentVal}") 


def main():
    portfolio = {'cash': 1, 'call': 0, 'stock': 0}
    initial_wealth = 100 
    stock_spot = 100
    strike = 110
    interest_rate = 0.05
    stock_volatility = 0.27
    expiry = 1
    N = 50
    currentTime = 0

    strategy = DeltaHedging(Direction.Long, PayoffType.Call, 
                            stock_spot, strike, expiry, interest_rate, stock_volatility)
    process = GeometricBrownianMotion(stock_spot, currentTime, N, expiry, interest_rate, stock_volatility)
    test = TradingSimulator(initial_wealth, process, strategy)
    test.trading()
    print(test.book)
    # print(f"The PnL for delta hedging strategy is {test.PnL}")
    # process = GeometricBrownianMotion(stock_spot, currentTime, N, expiry, drift, stock_volatility, interest_rate)
    # payoff = max(test.PathsGeneration.currentVal - strike, 0)
    # print(f"The payoff of the call option is {payoff}")

main()



